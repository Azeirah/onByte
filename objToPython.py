import sys
import os
from pprint import pprint

import ntpath

if not len(sys.argv) >= 2:
    print("Please supply a .obj file")

objFilepath = sys.argv[1]
objName     = ntpath.basename(objFilepath).split(".")[0]

hFilepath   = "out/" + objName + ".h"
cFilepath   = "out/" + objName + ".c"

def createEmptyModel():
    return {
        "vertices":     0,
        "positions":    0,
        "texels":       0,
        "normals":      0,
        "faces":        0,

        # [x, y, z]
        "positionData": [],
        # [u, v]
        "texelData":    [],
        # [x, y, z]
        "normalData":   [],
        # [p, t, n, p, t, n, p, t, n]
        "faceData":     []
    }

def getModelInfo(path):
    model = createEmptyModel()

    with open(path, "r") as obj:
        for line in obj.readlines():
            type = line[0:2]

            if type == "v ":
                model["positions"] += 1
            if type == "vt":
                model["texels"]    += 1
            if type == "vn":
                model["normals"]   += 1
            if type == "f ":
                model["faces"]     += 1

    model["vertices"] = model["faces"] * 3

    return model

def extractObjData(path, model):
    with open(path, "r") as obj:
        for line in obj.readlines():
            type = line[0:2]

            if type == "v ":
                model["positionData"].append([float(x) for x in line.split(" ")[1:]])

            if type == "vt":
                model["texelData"].append([float(x) for x in line.split(" ")[1:]])

            if type == "vn":
                model["normalData"].append([float(x) for x in line.split(" ")[1:]])

            if type == "f ":
                points = [x.replace("\n", "") for x in line.split(" ")[1:]]
                for i, p in enumerate(points):
                    points[i] = [int(x) for x in points[i].split("/")]

                # flatten
                model["faceData"].append([item for sublist in points for item in sublist])

def generateHFileContents(model):
    HFile = ""
    HFile += "// this is a file automatically generated by the brekelParser"
    HFile += "\n\n"
    HFile += "const int   {name}Vertices;\n"          .format(name=objName)
    HFile += "const float {name}Positions[{size}];\n" .format(name=objName, size=model["vertices"] * 3)
    HFile += "const float {name}Texels[{size}];\n"    .format(name=objName, size=model["vertices"] * 2)
    HFile += "const float {name}Normals[{size}];\n"   .format(name=objName, size=model["vertices"] * 3)

    return HFile

def generateCPPFileContents(model):
    CPPFile = ""
    CPPFile += "// this is a file automatically generated by the brekelParser"
    CPPFile += "\n\n"
    CPPFile += "#include {name}.h\n\n"                   .format(name=objName)
    CPPFile += "const int {name}Vertices = {vertices};\n".format(name=objName, vertices=model["vertices"])

    # vertices
    CPPFile += "const float {name}Positions[{size}] = {{\n"  .format(name=objName, size=model["vertices"] * 3)
    for face in model["faceData"]:
        vertexA = face[0] - 1
        vertexB = face[3] - 1
        vertexC = face[6] - 1

        CPPFile += "    {p1}, {p2}, {p3},\n".format(p1=model["positionData"][vertexA][0], p2=model["positionData"][vertexA][1], p3=model["positionData"][vertexA][2])

        CPPFile += "    {p1}, {p2}, {p3},\n".format(p1=model["positionData"][vertexA][0], p2=model["positionData"][vertexA][1], p3=model["positionData"][vertexA][2])

        CPPFile += "    {p1}, {p2}, {p3},\n".format(p1=model["positionData"][vertexA][0], p2=model["positionData"][vertexA][1], p3=model["positionData"][vertexA][2])
    CPPFile += "};\n\n"

    # texels
    CPPFile += "const float {name}Texels[{size}] = {{\n".format(name=objName, size=model["vertices"] * 2)
    for face in model["faceData"]:
        vertexA = face[1] - 1
        vertexB = face[4] - 1
        vertexC = face[7] - 1

        CPPFile += "    {p1}, {p2},\n".format(p1=model["texelData"][vertexA][0], p2=model["texelData"][vertexA][1])
        CPPFile += "    {p1}, {p2},\n".format(p1=model["texelData"][vertexA][0], p2=model["texelData"][vertexA][1])
        CPPFile += "    {p1}, {p2},\n".format(p1=model["texelData"][vertexA][0], p2=model["texelData"][vertexA][1])
    CPPFile += "};\n\n"

    # normals
    CPPFile += "const float {name}Normals[{size}] = {{\n".format(name=objName, size=model["vertices"] * 3)
    for face in model["faceData"]:
        vertexA = face[2] - 1
        vertexB = face[5] - 1
        vertexC = face[8] - 1

        CPPFile += "    {p1}, {p2}, {p3},\n".format(p1=model["normalData"][vertexA][0], p2=model["normalData"][vertexA][1], p3=model["normalData"][vertexA][2])

        CPPFile += "    {p1}, {p2}, {p3},\n".format(p1=model["normalData"][vertexA][0], p2=model["normalData"][vertexA][1], p3=model["normalData"][vertexA][2])

        CPPFile += "    {p1}, {p2}, {p3},\n".format(p1=model["normalData"][vertexA][0], p2=model["normalData"][vertexA][1], p3=model["normalData"][vertexA][2])
    CPPFile += "};\n\n"

    print(CPPFile)

    return CPPFile

def writeToFile(name, contents):
    with open(name, "w") as f:
        f.write(contents)

m = getModelInfo(objFilepath)
extractObjData(objFilepath, m)

HFile   = generateHFileContents(m)
CPPFile = generateCPPFileContents(m)

writeToFile(objName + ".h", HFile)
writeToFile(objName + ".cpp", CPPFile)
